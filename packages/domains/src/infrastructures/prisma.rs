// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
static DATAMODEL_STR : & 'static str = "generator client {\n  provider = \"cargo prisma\"\n  output   = \"../domains/src/infrastructures/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id          String  @id @default(cuid())\n  displayName String\n  email       String?\n}\n\nmodel WishList {\n  id              String            @id\n  url             String            @unique\n  scrapedAt       BigInt\n  title           String\n  EbookInWishList EbookInWishList[]\n}\n\nmodel Ebook {\n  id              String            @id\n  url             String            @unique\n  title           String\n  price           Float\n  snapshots       EbookSnapshot[]\n  EbookInWishList EbookInWishList[]\n}\n\nmodel EbookInWishList {\n  wish_list   WishList @relation(fields: [wishListId], references: [id])\n  wishListId String\n  ebook      Ebook    @relation(fields: [ebookId], references: [id])\n  ebookId    String\n\n  @@id([wishListId, ebookId])\n}\n\nmodel EbookSnapshot {\n  id           String @id @default(cuid())\n  ebook        Ebook  @relation(fields: [ebookId], references: [id])\n  ebookId      String\n  scrapedAt    BigInt\n  thumbnailUrl String\n  price        Float\n  discount     Float?\n  discountRate Float?\n  points       Float\n  pointsRate   Float\n}\n" ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if std::path::Path::new("./schema.prisma").exists() {
            url
        } else if std::path::Path::new("../../../../prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Please supply a datasource in your schema.prisma file");
    let (db_name, executor) =
        ::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
    let internal_model =
        ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(DATAMODEL_STR)
            .build(db_name);
    let query_schema = std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
        internal_model,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayNameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DisplayNameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DisplayNameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DisplayNameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DisplayNameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DisplayNameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DisplayNameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DisplayNameEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::DisplayNameMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DisplayNameNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDisplayName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DisplayName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("displayName").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DisplayName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("displayName").build()
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::EmailEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmailEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EmailMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmailNot(value)
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("email").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("email").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "displayName", "email"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(display_name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (display_name, _params)
    }
    #[macro_export]
    macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , display_name , email } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (display_name) , stringify ! (email)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "displayName" , "email"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; display_name) => { String } ; (@ field_type ; email) => { Option < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "User" , available fields are "id, display_name, email")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; display_name) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: display_name :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: email :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; display_name) => { "displayName" } ; (@ field_serde_name ; email) => { "email" } ; }
    pub use _select_user as select;
    pub enum SelectParam {
        Id(id::Select),
        DisplayName(display_name::Select),
        Email(email::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub id : String , pub display_name : String , pub email : Option < String > , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (display_name) , stringify ! (email)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; display_name) , & self . display_name) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , & self . email) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , display_name , email } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; display_name) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; display_name) => Ok (Field :: display_name) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) => Ok (Field :: email) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut display_name = None ; let mut email = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: display_name => { if display_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; display_name))) ; } display_name = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ; } email = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let display_name = display_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; display_name))) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ? ; Ok (Data { id , display_name , email , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "displayName" , "email"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; display_name) => { "displayName" } ; (@ field_serde_name ; email) => { "email" } ; }
    pub use _include_user as include;
    pub enum IncludeParam {
        Id(id::Include),
        DisplayName(display_name::Include),
        Email(email::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        #[serde(rename = "email")]
        pub email: Option<String>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetDisplayName(String),
        SetEmail(Option<String>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDisplayName(value) => (
                    "displayName".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEmail(value) => (
                    "email".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        DisplayName(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DisplayName(direction) => (
                    "displayName".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    "email".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        DisplayNameEquals(String),
        DisplayNameInVec(Vec<String>),
        DisplayNameNotInVec(Vec<String>),
        DisplayNameLt(String),
        DisplayNameLte(String),
        DisplayNameGt(String),
        DisplayNameGte(String),
        DisplayNameContains(String),
        DisplayNameStartsWith(String),
        DisplayNameEndsWith(String),
        DisplayNameMode(QueryMode),
        DisplayNameNot(String),
        EmailEquals(Option<String>),
        EmailInVec(Vec<String>),
        EmailNotInVec(Vec<String>),
        EmailLt(String),
        EmailLte(String),
        EmailGt(String),
        EmailGte(String),
        EmailContains(String),
        EmailStartsWith(String),
        EmailEndsWith(String),
        EmailMode(QueryMode),
        EmailNot(String),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisplayNameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::DisplayNameLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::DisplayNameMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::DisplayNameNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "displayName",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::EmailInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EmailNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EmailLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmailMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EmailNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "email",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
            )
        }
        pub fn create(self, display_name: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(display_name::set(display_name));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(display_name, mut _params)| {
                    _params.push(display_name::set(display_name));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (display_name, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(display_name::set(display_name));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("User", _outputs()),
                vec![],
            )
        }
    }
}
pub mod wish_list {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod url {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UrlEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Url(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UrlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UrlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UrlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UrlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UrlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UrlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UrlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UrlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UrlEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UrlMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UrlNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUrl(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
    }
    pub mod scraped_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ScrapedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ScrapedAt(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ScrapedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ScrapedAtNotInVec(value)
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ScrapedAtLt(value)
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ScrapedAtLte(value)
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ScrapedAtGt(value)
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ScrapedAtGte(value)
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ScrapedAtNot(value)
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementScrapedAt(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementScrapedAt(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyScrapedAt(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideScrapedAt(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetScrapedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ScrapedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("scrapedAt").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ScrapedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("scrapedAt").build()
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TitleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Title(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("title").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Title(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("title").build()
            }
        }
    }
    pub mod ebook_in_wish_list {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<ebook_in_wish_list::WhereParam>) -> WhereParam {
            WhereParam::EbookInWishListSome(value)
        }
        pub fn every(value: Vec<ebook_in_wish_list::WhereParam>) -> WhereParam {
            WhereParam::EbookInWishListEvery(value)
        }
        pub fn none(value: Vec<ebook_in_wish_list::WhereParam>) -> WhereParam {
            WhereParam::EbookInWishListNone(value)
        }
        pub struct Fetch(pub ebook_in_wish_list::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<ebook_in_wish_list::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: ebook_in_wish_list::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: ebook_in_wish_list::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::EbookInWishList(fetch.0)
            }
        }
        pub fn fetch(params: Vec<ebook_in_wish_list::WhereParam>) -> Fetch {
            Fetch(ebook_in_wish_list::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<ebook_in_wish_list::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<ebook_in_wish_list::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectEbookInWishList(params)
        }
        pub fn set(params: Vec<ebook_in_wish_list::UniqueWhereParam>) -> SetParam {
            SetParam::SetEbookInWishList(params)
        }
        pub struct Connect(pub Vec<ebook_in_wish_list::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectEbookInWishList(value.0)
            }
        }
        pub enum Include {
            Select(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::SelectParam>,
            ),
            Include(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::IncludeParam>,
            ),
            Fetch(ebook_in_wish_list::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EbookInWishList(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("EbookInWishList");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = ebook_in_wish_list::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(ebook_in_wish_list::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::SelectParam>,
            ),
            Include(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::IncludeParam>,
            ),
            Fetch(ebook_in_wish_list::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EbookInWishList(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("EbookInWishList");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(ebook_in_wish_list::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "url", "scrapedAt", "title"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        id: String,
        url: String,
        scraped_at: i64,
        title: String,
        _params: Vec<SetParam>,
    ) -> (String, String, i64, String, Vec<SetParam>) {
        (id, url, scraped_at, title, _params)
    }
    #[macro_export]
    macro_rules ! _select_wish_list { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: wish_list :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: wish_list :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: wish_list :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: wish_list :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , url , scraped_at , title , ebook_in_wish_list } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: wish_list :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (scraped_at) , stringify ! (title)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: wish_list :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: wish_list :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: wish_list :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: wish_list :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: wish_list :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "scrapedAt" , "title" , "EbookInWishList"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: wish_list :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; url) => { String } ; (@ field_type ; scraped_at) => { i64 } ; (@ field_type ; title) => { String } ; (@ field_type ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < ebook_in_wish_list :: Data > } ; (@ field_type ; ebook_in_wish_list) => { Vec < crate :: prisma :: ebook_in_wish_list :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "WishList" , available fields are "id, url, scraped_at, title, ebook_in_wish_list")) } ; (@ field_module ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook_in_wish_list :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: wish_list :: SelectParam > :: into ($ crate :: prisma :: wish_list :: id :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: wish_list :: SelectParam > :: into ($ crate :: prisma :: wish_list :: url :: Select) } ; (@ selection_field_to_selection_param ; scraped_at) => { Into :: < $ crate :: prisma :: wish_list :: SelectParam > :: into ($ crate :: prisma :: wish_list :: scraped_at :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < $ crate :: prisma :: wish_list :: SelectParam > :: into ($ crate :: prisma :: wish_list :: title :: Select) } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: wish_list :: SelectParam > :: into ($ crate :: prisma :: wish_list :: ebook_in_wish_list :: Select :: $ selection_mode ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: ebook_in_wish_list :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: wish_list :: SelectParam > :: into ($ crate :: prisma :: wish_list :: ebook_in_wish_list :: Select :: Fetch ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: wish_list :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; scraped_at) => { "scrapedAt" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; ebook_in_wish_list) => { "EbookInWishList" } ; }
    pub use _select_wish_list as select;
    pub enum SelectParam {
        Id(id::Select),
        Url(url::Select),
        ScrapedAt(scraped_at::Select),
        Title(title::Select),
        EbookInWishList(ebook_in_wish_list::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::ScrapedAt(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::EbookInWishList(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_wish_list { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: wish_list :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: wish_list :: _outputs () ; selections . extend ($ crate :: prisma :: wish_list :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: wish_list :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: wish_list :: _outputs () ; selections . extend ($ crate :: prisma :: wish_list :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { ebook_in_wish_list } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub id : String , pub url : String , pub scraped_at : i64 , pub title : String , $ (pub $ field : $ crate :: prisma :: wish_list :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (scraped_at) , stringify ! (title)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; scraped_at) , & self . scraped_at) ? ; state . serialize_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; title) , & self . title) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , url , scraped_at , title } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; scraped_at) , ", " , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; title) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; scraped_at) => Ok (Field :: scraped_at) , $ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; title) => Ok (Field :: title) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut url = None ; let mut scraped_at = None ; let mut title = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: scraped_at => { if scraped_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; scraped_at))) ; } scraped_at = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; title))) ; } title = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; id))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; url))) ? ; let scraped_at = scraped_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; scraped_at))) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: wish_list :: include ! (@ field_serde_name ; title))) ? ; Ok (Data { id , url , scraped_at , title , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "scrapedAt" , "title" , "EbookInWishList"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: wish_list :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < ebook_in_wish_list :: Data > } ; (@ field_type ; ebook_in_wish_list) => { Vec < crate :: prisma :: ebook_in_wish_list :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "WishList" , available relations are "ebook_in_wish_list")) } ; (@ field_module ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook_in_wish_list :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: wish_list :: IncludeParam > :: into ($ crate :: prisma :: wish_list :: ebook_in_wish_list :: Include :: $ selection_mode ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: ebook_in_wish_list :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: wish_list :: IncludeParam > :: into ($ crate :: prisma :: wish_list :: ebook_in_wish_list :: Include :: Fetch ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: wish_list :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; scraped_at) => { "scrapedAt" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; ebook_in_wish_list) => { "EbookInWishList" } ; }
    pub use _include_wish_list as include;
    pub enum IncludeParam {
        Id(id::Include),
        Url(url::Include),
        ScrapedAt(scraped_at::Include),
        Title(title::Include),
        EbookInWishList(ebook_in_wish_list::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::ScrapedAt(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::EbookInWishList(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "scrapedAt")]
        pub scraped_at: i64,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "EbookInWishList")]
        pub ebook_in_wish_list: Option<Vec<super::ebook_in_wish_list::Data>>,
    }
    impl Data {
        pub fn ebook_in_wish_list(
            &self,
        ) -> Result<
            &Vec<super::ebook_in_wish_list::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.ebook_in_wish_list.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(ebook_in_wish_list)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        EbookInWishList(super::ebook_in_wish_list::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::EbookInWishList(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::ebook_in_wish_list::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("EbookInWishList");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUrl(String),
        SetScrapedAt(i64),
        IncrementScrapedAt(i64),
        DecrementScrapedAt(i64),
        MultiplyScrapedAt(i64),
        DivideScrapedAt(i64),
        SetTitle(String),
        ConnectEbookInWishList(Vec<super::ebook_in_wish_list::UniqueWhereParam>),
        DisconnectEbookInWishList(Vec<super::ebook_in_wish_list::UniqueWhereParam>),
        SetEbookInWishList(Vec<super::ebook_in_wish_list::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetUrl(value) => (
                    "url".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetScrapedAt(value) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementScrapedAt(value) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementScrapedAt(value) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyScrapedAt(value) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideScrapedAt(value) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    "title".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectEbookInWishList(where_params) => (
                    "EbookInWishList".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::ebook_in_wish_list::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectEbookInWishList(where_params) => (
                    "EbookInWishList".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::ebook_in_wish_list::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetEbookInWishList(where_params) => (
                    "EbookInWishList".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::ebook_in_wish_list::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Url(::prisma_client_rust::Direction),
        ScrapedAt(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Url(direction) => (
                    "url".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ScrapedAt(direction) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    "title".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UrlEquals(String),
        UrlInVec(Vec<String>),
        UrlNotInVec(Vec<String>),
        UrlLt(String),
        UrlLte(String),
        UrlGt(String),
        UrlGte(String),
        UrlContains(String),
        UrlStartsWith(String),
        UrlEndsWith(String),
        UrlMode(QueryMode),
        UrlNot(String),
        ScrapedAtEquals(i64),
        ScrapedAtInVec(Vec<i64>),
        ScrapedAtNotInVec(Vec<i64>),
        ScrapedAtLt(i64),
        ScrapedAtLte(i64),
        ScrapedAtGt(i64),
        ScrapedAtGte(i64),
        ScrapedAtNot(i64),
        TitleEquals(String),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleMode(QueryMode),
        TitleNot(String),
        EbookInWishListSome(Vec<super::ebook_in_wish_list::WhereParam>),
        EbookInWishListEvery(Vec<super::ebook_in_wish_list::WhereParam>),
        EbookInWishListNone(Vec<super::ebook_in_wish_list::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::IdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UrlNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UrlLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UrlMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::UrlNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "url",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ScrapedAtEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ScrapedAtInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ScrapedAtNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::ScrapedAtLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ScrapedAtLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ScrapedAtGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ScrapedAtGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ScrapedAtNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "scrapedAt",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::TitleEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::TitleNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::TitleLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::TitleMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::TitleNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "title",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookInWishListSome(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "EbookInWishList",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "some".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::EbookInWishListEvery(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "EbookInWishList",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "every".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
                Self::EbookInWishListNone(where_params) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "EbookInWishList",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "none".to_string(),
                            ::prisma_client_rust::PrismaValue::Object(
                                where_params
                                    .into_iter()
                                    .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                    .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                    .collect(),
                            ),
                        )]),
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UrlEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            url: String,
            scraped_at: i64,
            title: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(scraped_at::set(scraped_at));
            _params.push(title::set(title));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, i64, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, url, scraped_at, title, mut _params)| {
                    _params.push(id::set(id));
                    _params.push(url::set(url));
                    _params.push(scraped_at::set(scraped_at));
                    _params.push(title::set(title));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, url, scraped_at, title, mut _params): (String, String, i64, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(scraped_at::set(scraped_at));
            _params.push(title::set(title));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("WishList", _outputs()),
                vec![],
            )
        }
    }
}
pub mod ebook {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod url {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UrlEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Url(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UrlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UrlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UrlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UrlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UrlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UrlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UrlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UrlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UrlEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UrlMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UrlNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUrl(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TitleEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TitleNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TitleLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TitleLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TitleGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TitleGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TitleContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TitleStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TitleEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::TitleMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TitleNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTitle(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Title(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("title").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Title(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("title").build()
            }
        }
    }
    pub mod price {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: f64) -> T {
            Set(value).into()
        }
        pub fn equals(value: f64) -> WhereParam {
            WhereParam::PriceEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Price(direction)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PriceInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PriceNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::PriceLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::PriceLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::PriceGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::PriceGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::PriceNot(value)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementPrice(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementPrice(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyPrice(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DividePrice(value)
        }
        pub struct Set(pub f64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrice(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Price(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("price").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Price(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("price").build()
            }
        }
    }
    pub mod snapshots {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<ebook_snapshot::WhereParam>) -> WhereParam {
            WhereParam::SnapshotsSome(value)
        }
        pub fn every(value: Vec<ebook_snapshot::WhereParam>) -> WhereParam {
            WhereParam::SnapshotsEvery(value)
        }
        pub fn none(value: Vec<ebook_snapshot::WhereParam>) -> WhereParam {
            WhereParam::SnapshotsNone(value)
        }
        pub struct Fetch(pub ebook_snapshot::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<ebook_snapshot::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: ebook_snapshot::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: ebook_snapshot::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Snapshots(fetch.0)
            }
        }
        pub fn fetch(params: Vec<ebook_snapshot::WhereParam>) -> Fetch {
            Fetch(ebook_snapshot::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<ebook_snapshot::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<ebook_snapshot::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectSnapshots(params)
        }
        pub fn set(params: Vec<ebook_snapshot::UniqueWhereParam>) -> SetParam {
            SetParam::SetSnapshots(params)
        }
        pub struct Connect(pub Vec<ebook_snapshot::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectSnapshots(value.0)
            }
        }
        pub enum Include {
            Select(ebook_snapshot::ManyArgs, Vec<ebook_snapshot::SelectParam>),
            Include(ebook_snapshot::ManyArgs, Vec<ebook_snapshot::IncludeParam>),
            Fetch(ebook_snapshot::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Snapshots(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("snapshots");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = ebook_snapshot::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(ebook_snapshot::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: ebook_snapshot::ManyArgs,
                nested_selections: Vec<ebook_snapshot::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: ebook_snapshot::ManyArgs,
                nested_selections: Vec<ebook_snapshot::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(ebook_snapshot::ManyArgs, Vec<ebook_snapshot::SelectParam>),
            Include(ebook_snapshot::ManyArgs, Vec<ebook_snapshot::IncludeParam>),
            Fetch(ebook_snapshot::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Snapshots(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("snapshots");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(ebook_snapshot::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: ebook_snapshot::ManyArgs,
                nested_selections: Vec<ebook_snapshot::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: ebook_snapshot::ManyArgs,
                nested_selections: Vec<ebook_snapshot::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod ebook_in_wish_list {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<ebook_in_wish_list::WhereParam>) -> WhereParam {
            WhereParam::EbookInWishListSome(value)
        }
        pub fn every(value: Vec<ebook_in_wish_list::WhereParam>) -> WhereParam {
            WhereParam::EbookInWishListEvery(value)
        }
        pub fn none(value: Vec<ebook_in_wish_list::WhereParam>) -> WhereParam {
            WhereParam::EbookInWishListNone(value)
        }
        pub struct Fetch(pub ebook_in_wish_list::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<ebook_in_wish_list::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: ebook_in_wish_list::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: ebook_in_wish_list::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::EbookInWishList(fetch.0)
            }
        }
        pub fn fetch(params: Vec<ebook_in_wish_list::WhereParam>) -> Fetch {
            Fetch(ebook_in_wish_list::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<ebook_in_wish_list::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<ebook_in_wish_list::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectEbookInWishList(params)
        }
        pub fn set(params: Vec<ebook_in_wish_list::UniqueWhereParam>) -> SetParam {
            SetParam::SetEbookInWishList(params)
        }
        pub struct Connect(pub Vec<ebook_in_wish_list::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectEbookInWishList(value.0)
            }
        }
        pub enum Include {
            Select(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::SelectParam>,
            ),
            Include(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::IncludeParam>,
            ),
            Fetch(ebook_in_wish_list::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EbookInWishList(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("EbookInWishList");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = ebook_in_wish_list::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(ebook_in_wish_list::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::SelectParam>,
            ),
            Include(
                ebook_in_wish_list::ManyArgs,
                Vec<ebook_in_wish_list::IncludeParam>,
            ),
            Fetch(ebook_in_wish_list::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EbookInWishList(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("EbookInWishList");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(ebook_in_wish_list::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: ebook_in_wish_list::ManyArgs,
                nested_selections: Vec<ebook_in_wish_list::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["id", "url", "title", "price"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        id: String,
        url: String,
        title: String,
        price: f64,
        _params: Vec<SetParam>,
    ) -> (String, String, String, f64, Vec<SetParam>) {
        (id, url, title, price, _params)
    }
    #[macro_export]
    macro_rules ! _select_ebook { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: ebook :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: ebook :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: ebook :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: ebook :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: ebook :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: ebook :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , url , title , price , snapshots , ebook_in_wish_list } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: ebook :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (title) , stringify ! (price)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: ebook :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: ebook :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: ebook :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "title" , "price" , "snapshots" , "EbookInWishList"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: ebook :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; url) => { String } ; (@ field_type ; title) => { String } ; (@ field_type ; price) => { f64 } ; (@ field_type ; snapshots : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < snapshots :: Data > } ; (@ field_type ; snapshots) => { Vec < crate :: prisma :: ebook_snapshot :: Data > } ; (@ field_type ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < ebook_in_wish_list :: Data > } ; (@ field_type ; ebook_in_wish_list) => { Vec < crate :: prisma :: ebook_in_wish_list :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Ebook" , available fields are "id, url, title, price, snapshots, ebook_in_wish_list")) } ; (@ field_module ; snapshots : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook_snapshot :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook_in_wish_list :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: id :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: url :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: title :: Select) } ; (@ selection_field_to_selection_param ; price) => { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: price :: Select) } ; (@ selection_field_to_selection_param ; snapshots $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: snapshots :: Select :: $ selection_mode ($ crate :: prisma :: ebook_snapshot :: ManyArgs :: new ($ crate :: prisma :: ebook_snapshot :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: ebook_snapshot :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; snapshots $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: snapshots :: Select :: Fetch ($ crate :: prisma :: ebook_snapshot :: ManyArgs :: new ($ crate :: prisma :: ebook_snapshot :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: ebook_in_wish_list :: Select :: $ selection_mode ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: ebook_in_wish_list :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook :: SelectParam > :: into ($ crate :: prisma :: ebook :: ebook_in_wish_list :: Select :: Fetch ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: ebook :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; snapshots) => { "snapshots" } ; (@ field_serde_name ; ebook_in_wish_list) => { "EbookInWishList" } ; }
    pub use _select_ebook as select;
    pub enum SelectParam {
        Id(id::Select),
        Url(url::Select),
        Title(title::Select),
        Price(price::Select),
        Snapshots(snapshots::Select),
        EbookInWishList(ebook_in_wish_list::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::Snapshots(data) => data.to_selection(),
                Self::EbookInWishList(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_ebook { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: ebook :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: ebook :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: ebook :: _outputs () ; selections . extend ($ crate :: prisma :: ebook :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: ebook :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: ebook :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: ebook :: _outputs () ; selections . extend ($ crate :: prisma :: ebook :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { snapshots , ebook_in_wish_list } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub id : String , pub url : String , pub title : String , pub price : f64 , $ (pub $ field : $ crate :: prisma :: ebook :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (title) , stringify ! (price)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; title) , & self . title) ? ; state . serialize_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; price) , & self . price) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , url , title , price } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; title) , ", " , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; price) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; title) => Ok (Field :: title) , $ crate :: prisma :: ebook :: include ! (@ field_serde_name ; price) => Ok (Field :: price) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut url = None ; let mut title = None ; let mut price = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; title))) ; } title = Some (map . next_value () ?) ; } Field :: price => { if price . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; price))) ; } price = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; id))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; url))) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; title))) ? ; let price = price . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook :: include ! (@ field_serde_name ; price))) ? ; Ok (Data { id , url , title , price , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "title" , "price" , "snapshots" , "EbookInWishList"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: ebook :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; snapshots : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < snapshots :: Data > } ; (@ field_type ; snapshots) => { Vec < crate :: prisma :: ebook_snapshot :: Data > } ; (@ field_type ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < ebook_in_wish_list :: Data > } ; (@ field_type ; ebook_in_wish_list) => { Vec < crate :: prisma :: ebook_in_wish_list :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Ebook" , available relations are "snapshots, ebook_in_wish_list")) } ; (@ field_module ; snapshots : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook_snapshot :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; ebook_in_wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook_in_wish_list :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; snapshots $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook :: IncludeParam > :: into ($ crate :: prisma :: ebook :: snapshots :: Include :: $ selection_mode ($ crate :: prisma :: ebook_snapshot :: ManyArgs :: new ($ crate :: prisma :: ebook_snapshot :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: ebook_snapshot :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; snapshots $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook :: IncludeParam > :: into ($ crate :: prisma :: ebook :: snapshots :: Include :: Fetch ($ crate :: prisma :: ebook_snapshot :: ManyArgs :: new ($ crate :: prisma :: ebook_snapshot :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook :: IncludeParam > :: into ($ crate :: prisma :: ebook :: ebook_in_wish_list :: Include :: $ selection_mode ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: ebook_in_wish_list :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook_in_wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook :: IncludeParam > :: into ($ crate :: prisma :: ebook :: ebook_in_wish_list :: Include :: Fetch ($ crate :: prisma :: ebook_in_wish_list :: ManyArgs :: new ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: ebook :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; snapshots) => { "snapshots" } ; (@ field_serde_name ; ebook_in_wish_list) => { "EbookInWishList" } ; }
    pub use _include_ebook as include;
    pub enum IncludeParam {
        Id(id::Include),
        Url(url::Include),
        Title(title::Include),
        Price(price::Include),
        Snapshots(snapshots::Include),
        EbookInWishList(ebook_in_wish_list::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::Snapshots(data) => data.to_selection(),
                Self::EbookInWishList(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "price")]
        pub price: f64,
        #[serde(rename = "snapshots")]
        pub snapshots: Option<Vec<super::ebook_snapshot::Data>>,
        #[serde(rename = "EbookInWishList")]
        pub ebook_in_wish_list: Option<Vec<super::ebook_in_wish_list::Data>>,
    }
    impl Data {
        pub fn snapshots(
            &self,
        ) -> Result<&Vec<super::ebook_snapshot::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.snapshots
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(snapshots),
                ))
        }
        pub fn ebook_in_wish_list(
            &self,
        ) -> Result<
            &Vec<super::ebook_in_wish_list::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.ebook_in_wish_list.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(ebook_in_wish_list)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Snapshots(super::ebook_snapshot::ManyArgs),
        EbookInWishList(super::ebook_in_wish_list::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Snapshots(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::ebook_snapshot::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("snapshots");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::EbookInWishList(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::ebook_in_wish_list::_outputs());
                    let mut builder = ::prisma_client_rust::Selection::builder("EbookInWishList");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUrl(String),
        SetTitle(String),
        SetPrice(f64),
        IncrementPrice(f64),
        DecrementPrice(f64),
        MultiplyPrice(f64),
        DividePrice(f64),
        ConnectSnapshots(Vec<super::ebook_snapshot::UniqueWhereParam>),
        DisconnectSnapshots(Vec<super::ebook_snapshot::UniqueWhereParam>),
        SetSnapshots(Vec<super::ebook_snapshot::UniqueWhereParam>),
        ConnectEbookInWishList(Vec<super::ebook_in_wish_list::UniqueWhereParam>),
        DisconnectEbookInWishList(Vec<super::ebook_in_wish_list::UniqueWhereParam>),
        SetEbookInWishList(Vec<super::ebook_in_wish_list::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetUrl (value) => ("url" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetTitle (value) => ("title" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) , SetParam :: IncrementPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DividePrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: ConnectSnapshots (where_params) => ("snapshots" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: ebook_snapshot :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectSnapshots (where_params) => ("snapshots" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: ebook_snapshot :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetSnapshots (where_params) => ("snapshots" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: ebook_snapshot :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: ConnectEbookInWishList (where_params) => ("EbookInWishList" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: ebook_in_wish_list :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectEbookInWishList (where_params) => ("EbookInWishList" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: ebook_in_wish_list :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetEbookInWishList (where_params) => ("EbookInWishList" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: ebook_in_wish_list :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Url(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Price(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Url(direction) => (
                    "url".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    "title".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Price(direction) => (
                    "price".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        UrlEquals(String),
        UrlInVec(Vec<String>),
        UrlNotInVec(Vec<String>),
        UrlLt(String),
        UrlLte(String),
        UrlGt(String),
        UrlGte(String),
        UrlContains(String),
        UrlStartsWith(String),
        UrlEndsWith(String),
        UrlMode(QueryMode),
        UrlNot(String),
        TitleEquals(String),
        TitleInVec(Vec<String>),
        TitleNotInVec(Vec<String>),
        TitleLt(String),
        TitleLte(String),
        TitleGt(String),
        TitleGte(String),
        TitleContains(String),
        TitleStartsWith(String),
        TitleEndsWith(String),
        TitleMode(QueryMode),
        TitleNot(String),
        PriceEquals(f64),
        PriceInVec(Vec<f64>),
        PriceNotInVec(Vec<f64>),
        PriceLt(f64),
        PriceLte(f64),
        PriceGt(f64),
        PriceGte(f64),
        PriceNot(f64),
        SnapshotsSome(Vec<super::ebook_snapshot::WhereParam>),
        SnapshotsEvery(Vec<super::ebook_snapshot::WhereParam>),
        SnapshotsNone(Vec<super::ebook_snapshot::WhereParam>),
        EbookInWishListSome(Vec<super::ebook_in_wish_list::WhereParam>),
        EbookInWishListEvery(Vec<super::ebook_in_wish_list::WhereParam>),
        EbookInWishListNone(Vec<super::ebook_in_wish_list::WhereParam>),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self { Self :: Not (value) => :: prisma_client_rust :: SerializedWhere :: new ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: Or (value) => :: prisma_client_rust :: SerializedWhere :: new ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => :: prisma_client_rust :: SerializedWhere :: new ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: IdEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: IdNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: IdLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: IdNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: UrlNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: UrlLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UrlMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: UrlNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: TitleNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: TitleLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: TitleMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: TitleNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("title" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PriceEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PriceNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PriceLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: SnapshotsSome (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("snapshots" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: SnapshotsEvery (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("snapshots" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: SnapshotsNone (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("snapshots" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: EbookInWishListSome (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("EbookInWishList" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: EbookInWishListEvery (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("EbookInWishList" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: EbookInWishListNone (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("EbookInWishList" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UrlEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            id: String,
            url: String,
            title: String,
            price: f64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(title::set(title));
            _params.push(price::set(price));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, f64, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(id, url, title, price, mut _params)| {
                    _params.push(id::set(id));
                    _params.push(url::set(url));
                    _params.push(title::set(title));
                    _params.push(price::set(price));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, url, title, price, mut _params): (String, String, String, f64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(title::set(title));
            _params.push(price::set(price));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("Ebook", _outputs()),
                vec![],
            )
        }
    }
}
pub mod ebook_in_wish_list {
    use super::_prisma::*;
    use super::*;
    pub mod wish_list {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<wish_list::WhereParam>) -> WhereParam {
            WhereParam::WishListIs(value)
        }
        pub fn is_not(value: Vec<wish_list::WhereParam>) -> WhereParam {
            WhereParam::WishListIsNot(value)
        }
        pub struct Fetch(pub wish_list::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<wish_list::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::WishList(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(wish_list::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: wish_list::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(wish_list::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectWishList(value.0)
            }
        }
        pub enum Include {
            Select(Vec<wish_list::SelectParam>),
            Include(Vec<wish_list::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WishList(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("wish_list");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = wish_list::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(wish_list::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<wish_list::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<wish_list::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<wish_list::SelectParam>),
            Include(Vec<wish_list::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WishList(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("wish_list");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(wish_list::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<wish_list::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<wish_list::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod wish_list_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::WishListIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WishListId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::WishListIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::WishListIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::WishListIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::WishListIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::WishListIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::WishListIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::WishListIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::WishListIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::WishListIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::WishListIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::WishListIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetWishListId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WishListId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("wishListId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WishListId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("wishListId").build()
            }
        }
    }
    pub mod ebook {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<ebook::WhereParam>) -> WhereParam {
            WhereParam::EbookIs(value)
        }
        pub fn is_not(value: Vec<ebook::WhereParam>) -> WhereParam {
            WhereParam::EbookIsNot(value)
        }
        pub struct Fetch(pub ebook::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<ebook::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Ebook(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(ebook::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: ebook::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(ebook::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectEbook(value.0)
            }
        }
        pub enum Include {
            Select(Vec<ebook::SelectParam>),
            Include(Vec<ebook::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Ebook(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("ebook");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = ebook::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(ebook::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<ebook::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<ebook::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<ebook::SelectParam>),
            Include(Vec<ebook::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Ebook(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("ebook");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(ebook::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<ebook::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<ebook::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod ebook_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EbookIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EbookId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EbookIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EbookIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EbookIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EbookIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EbookIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EbookIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EbookIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EbookIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EbookIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EbookIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EbookIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEbookId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EbookId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ebookId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EbookId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ebookId").build()
            }
        }
    }
    pub fn wish_list_id_ebook_id<T: From<UniqueWhereParam>>(
        wish_list_id: String,
        ebook_id: String,
    ) -> T {
        UniqueWhereParam::WishListIdEbookIdEquals(wish_list_id, ebook_id).into()
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        ["wishListId", "ebookId"]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    pub fn create(
        wish_list_id: String,
        ebook_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (wish_list_id, ebook_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_ebook_in_wish_list { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: ebook_in_wish_list :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_in_wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: ebook_in_wish_list :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_in_wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { wish_list , wish_list_id , ebook , ebook_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (wish_list_id) , stringify ! (ebook_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["wish_list" , "wishListId" , "ebook" , "ebookId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: ebook_in_wish_list :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { wish_list :: Data } ; (@ field_type ; wish_list) => { crate :: prisma :: wish_list :: Data } ; (@ field_type ; wish_list_id) => { String } ; (@ field_type ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { ebook :: Data } ; (@ field_type ; ebook) => { crate :: prisma :: ebook :: Data } ; (@ field_type ; ebook_id) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "EbookInWishList" , available fields are "wish_list, wish_list_id, ebook, ebook_id")) } ; (@ field_module ; wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: wish_list :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: SelectParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: wish_list :: Select :: $ selection_mode ($ crate :: prisma :: wish_list :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: SelectParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: wish_list :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; wish_list_id) => { Into :: < $ crate :: prisma :: ebook_in_wish_list :: SelectParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: wish_list_id :: Select) } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: SelectParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: ebook :: Select :: $ selection_mode ($ crate :: prisma :: ebook :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: SelectParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: ebook :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; ebook_id) => { Into :: < $ crate :: prisma :: ebook_in_wish_list :: SelectParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: ebook_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: ebook_in_wish_list :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; wish_list) => { "wish_list" } ; (@ field_serde_name ; wish_list_id) => { "wishListId" } ; (@ field_serde_name ; ebook) => { "ebook" } ; (@ field_serde_name ; ebook_id) => { "ebookId" } ; }
    pub use _select_ebook_in_wish_list as select;
    pub enum SelectParam {
        WishList(wish_list::Select),
        WishListId(wish_list_id::Select),
        Ebook(ebook::Select),
        EbookId(ebook_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::WishList(data) => data.to_selection(),
                Self::WishListId(data) => data.to_selection(),
                Self::Ebook(data) => data.to_selection(),
                Self::EbookId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_ebook_in_wish_list { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: ebook_in_wish_list :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_in_wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: ebook_in_wish_list :: _outputs () ; selections . extend ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: ebook_in_wish_list :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_in_wish_list :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: ebook_in_wish_list :: _outputs () ; selections . extend ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { wish_list , ebook } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub wish_list_id : String , pub ebook_id : String , $ (pub $ field : $ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (wish_list_id) , stringify ! (ebook_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; wish_list_id) , & self . wish_list_id) ? ; state . serialize_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; ebook_id) , & self . ebook_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , wish_list_id , ebook_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; wish_list_id) , ", " , $ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; ebook_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; wish_list_id) => Ok (Field :: wish_list_id) , $ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; ebook_id) => Ok (Field :: ebook_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut wish_list_id = None ; let mut ebook_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: wish_list_id => { if wish_list_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; wish_list_id))) ; } wish_list_id = Some (map . next_value () ?) ; } Field :: ebook_id => { if ebook_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; ebook_id))) ; } ebook_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; $ field))) ? ;) * let wish_list_id = wish_list_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; wish_list_id))) ? ; let ebook_id = ebook_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_in_wish_list :: include ! (@ field_serde_name ; ebook_id))) ? ; Ok (Data { wish_list_id , ebook_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["wish_list" , "wishListId" , "ebook" , "ebookId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: ebook_in_wish_list :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { wish_list :: Data } ; (@ field_type ; wish_list) => { crate :: prisma :: wish_list :: Data } ; (@ field_type ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { ebook :: Data } ; (@ field_type ; ebook) => { crate :: prisma :: ebook :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "EbookInWishList" , available relations are "wish_list, ebook")) } ; (@ field_module ; wish_list : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: wish_list :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: IncludeParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: wish_list :: Include :: $ selection_mode ($ crate :: prisma :: wish_list :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; wish_list $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: IncludeParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: wish_list :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: IncludeParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: ebook :: Include :: $ selection_mode ($ crate :: prisma :: ebook :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook_in_wish_list :: IncludeParam > :: into ($ crate :: prisma :: ebook_in_wish_list :: ebook :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: ebook_in_wish_list :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; wish_list) => { "wish_list" } ; (@ field_serde_name ; wish_list_id) => { "wishListId" } ; (@ field_serde_name ; ebook) => { "ebook" } ; (@ field_serde_name ; ebook_id) => { "ebookId" } ; }
    pub use _include_ebook_in_wish_list as include;
    pub enum IncludeParam {
        WishList(wish_list::Include),
        WishListId(wish_list_id::Include),
        Ebook(ebook::Include),
        EbookId(ebook_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::WishList(data) => data.to_selection(),
                Self::WishListId(data) => data.to_selection(),
                Self::Ebook(data) => data.to_selection(),
                Self::EbookId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "wish_list")]
        pub wish_list: Option<Box<super::wish_list::Data>>,
        #[serde(rename = "wishListId")]
        pub wish_list_id: String,
        #[serde(rename = "ebook")]
        pub ebook: Option<Box<super::ebook::Data>>,
        #[serde(rename = "ebookId")]
        pub ebook_id: String,
    }
    impl Data {
        pub fn wish_list(
            &self,
        ) -> Result<&super::wish_list::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.wish_list
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(wish_list),
                ))
                .map(|v| v.as_ref())
        }
        pub fn ebook(
            &self,
        ) -> Result<&super::ebook::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.ebook
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(ebook),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        WishList(super::wish_list::UniqueArgs),
        Ebook(super::ebook::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::WishList(args) => {
                    let mut selections = super::wish_list::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("wish_list");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Ebook(args) => {
                    let mut selections = super::ebook::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("ebook");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        ConnectWishList(super::wish_list::UniqueWhereParam),
        SetWishListId(String),
        ConnectEbook(super::ebook::UniqueWhereParam),
        SetEbookId(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::ConnectWishList(where_param) => (
                    "wish_list".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::wish_list::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetWishListId(value) => (
                    "wishListId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectEbook(where_param) => (
                    "ebook".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::ebook::WhereParam>::into)
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetEbookId(value) => (
                    "ebookId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        WishListId(::prisma_client_rust::Direction),
        EbookId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::WishListId(direction) => (
                    "wishListId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EbookId(direction) => (
                    "ebookId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        WishListIdEbookIdEquals(String, String),
        WishListIs(Vec<super::wish_list::WhereParam>),
        WishListIsNot(Vec<super::wish_list::WhereParam>),
        WishListIdEquals(String),
        WishListIdInVec(Vec<String>),
        WishListIdNotInVec(Vec<String>),
        WishListIdLt(String),
        WishListIdLte(String),
        WishListIdGt(String),
        WishListIdGte(String),
        WishListIdContains(String),
        WishListIdStartsWith(String),
        WishListIdEndsWith(String),
        WishListIdMode(QueryMode),
        WishListIdNot(String),
        EbookIs(Vec<super::ebook::WhereParam>),
        EbookIsNot(Vec<super::ebook::WhereParam>),
        EbookIdEquals(String),
        EbookIdInVec(Vec<String>),
        EbookIdNotInVec(Vec<String>),
        EbookIdLt(String),
        EbookIdLte(String),
        EbookIdGt(String),
        EbookIdGte(String),
        EbookIdContains(String),
        EbookIdStartsWith(String),
        EbookIdEndsWith(String),
        EbookIdMode(QueryMode),
        EbookIdNot(String),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self {
                Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        value
                            .into_iter()
                            .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                            .map(Into::into)
                            .collect(),
                    ),
                ),
                Self::WishListIdEbookIdEquals(wish_list_id, ebook_id) => {
                    ::prisma_client_rust::SerializedWhere::new(
                        "wishListId_ebookId",
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![
                            (
                                "wishListId".to_string(),
                                ::prisma_client_rust::PrismaValue::String(wish_list_id),
                            ),
                            (
                                "ebookId".to_string(),
                                ::prisma_client_rust::PrismaValue::String(ebook_id),
                            ),
                        ]),
                    )
                }
                Self::WishListIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "wish_list",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::WishListIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "wish_list",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::WishListIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::WishListIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::WishListIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::WishListIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::WishListIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "wishListId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIs(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "ebook",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::EbookIsNot(where_params) => ::prisma_client_rust::SerializedWhere::new(
                    "ebook",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(Into::<::prisma_client_rust::SerializedWhere>::into)
                                .map(::prisma_client_rust::SerializedWhere::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::EbookIdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EbookIdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::EbookIdLt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdLte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdGt(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdGte(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdContains(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EbookIdMode(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "mode".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                ),
                Self::EbookIdNot(value) => ::prisma_client_rust::SerializedWhere::new(
                    "ebookId",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        WishListIdEbookIdEquals(String, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::WishListIdEbookIdEquals(wish_list_id, ebook_id) => {
                    Self::WishListIdEbookIdEquals(wish_list_id, ebook_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            wish_list: super::wish_list::UniqueWhereParam,
            ebook: super::ebook::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(wish_list::connect(wish_list));
            _params.push(ebook::connect(ebook));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _params,
            )
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(wish_list_id, ebook_id, mut _params)| {
                    _params.push(wish_list_id::set(wish_list_id));
                    _params.push(ebook_id::set(ebook_id));
                    _params
                })
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (wish_list, ebook, mut _params): (
                super::wish_list::UniqueWhereParam,
                super::ebook::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(wish_list::connect(wish_list));
            _params.push(ebook::connect(ebook));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookInWishList", _outputs()),
                vec![],
            )
        }
    }
}
pub mod ebook_snapshot {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::IdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod ebook {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<ebook::WhereParam>) -> WhereParam {
            WhereParam::EbookIs(value)
        }
        pub fn is_not(value: Vec<ebook::WhereParam>) -> WhereParam {
            WhereParam::EbookIsNot(value)
        }
        pub struct Fetch(pub ebook::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<ebook::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Ebook(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(ebook::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: ebook::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(ebook::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectEbook(value.0)
            }
        }
        pub enum Include {
            Select(Vec<ebook::SelectParam>),
            Include(Vec<ebook::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Ebook(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("ebook");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = ebook::_outputs();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(ebook::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<ebook::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<ebook::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<ebook::SelectParam>),
            Include(Vec<ebook::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Ebook(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("ebook");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection.nested_selections(ebook::_outputs());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<ebook::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<ebook::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod ebook_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EbookIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EbookId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EbookIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EbookIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EbookIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EbookIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EbookIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EbookIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EbookIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EbookIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EbookIdEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EbookIdMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EbookIdNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEbookId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EbookId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ebookId").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EbookId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ebookId").build()
            }
        }
    }
    pub mod scraped_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ScrapedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ScrapedAt(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ScrapedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ScrapedAtNotInVec(value)
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ScrapedAtLt(value)
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ScrapedAtLte(value)
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ScrapedAtGt(value)
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ScrapedAtGte(value)
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ScrapedAtNot(value)
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementScrapedAt(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementScrapedAt(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyScrapedAt(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideScrapedAt(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetScrapedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ScrapedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("scrapedAt").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ScrapedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("scrapedAt").build()
            }
        }
    }
    pub mod thumbnail_url {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ThumbnailUrl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ThumbnailUrlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ThumbnailUrlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlEndsWith(value)
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ThumbnailUrlMode(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ThumbnailUrlNot(value)
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetThumbnailUrl(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ThumbnailUrl(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("thumbnailUrl").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ThumbnailUrl(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("thumbnailUrl").build()
            }
        }
    }
    pub mod price {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: f64) -> T {
            Set(value).into()
        }
        pub fn equals(value: f64) -> WhereParam {
            WhereParam::PriceEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Price(direction)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PriceInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PriceNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::PriceLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::PriceLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::PriceGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::PriceGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::PriceNot(value)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementPrice(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementPrice(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyPrice(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DividePrice(value)
        }
        pub struct Set(pub f64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPrice(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Price(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("price").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Price(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("price").build()
            }
        }
    }
    pub mod discount {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<f64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<f64>) -> WhereParam {
            WhereParam::DiscountEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Discount(direction)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::DiscountInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::DiscountNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::DiscountLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::DiscountLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::DiscountGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::DiscountGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::DiscountNot(value)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementDiscount(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementDiscount(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyDiscount(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DivideDiscount(value)
        }
        pub struct Set(pub Option<f64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDiscount(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Discount(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("discount").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Discount(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("discount").build()
            }
        }
    }
    pub mod discount_rate {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<f64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<f64>) -> WhereParam {
            WhereParam::DiscountRateEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DiscountRate(direction)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::DiscountRateInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::DiscountRateNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::DiscountRateLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::DiscountRateLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::DiscountRateGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::DiscountRateGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::DiscountRateNot(value)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementDiscountRate(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementDiscountRate(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyDiscountRate(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DivideDiscountRate(value)
        }
        pub struct Set(pub Option<f64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDiscountRate(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DiscountRate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("discountRate").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DiscountRate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("discountRate").build()
            }
        }
    }
    pub mod points {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: f64) -> T {
            Set(value).into()
        }
        pub fn equals(value: f64) -> WhereParam {
            WhereParam::PointsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Points(direction)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PointsInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PointsNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::PointsLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::PointsLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::PointsGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::PointsGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::PointsNot(value)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementPoints(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementPoints(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyPoints(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DividePoints(value)
        }
        pub struct Set(pub f64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPoints(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Points(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("points").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Points(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("points").build()
            }
        }
    }
    pub mod points_rate {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: f64) -> T {
            Set(value).into()
        }
        pub fn equals(value: f64) -> WhereParam {
            WhereParam::PointsRateEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PointsRate(direction)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PointsRateInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::PointsRateNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::PointsRateLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::PointsRateLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::PointsRateGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::PointsRateGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::PointsRateNot(value)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementPointsRate(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementPointsRate(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyPointsRate(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DividePointsRate(value)
        }
        pub struct Set(pub f64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPointsRate(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PointsRate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("pointsRate").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PointsRate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("pointsRate").build()
            }
        }
    }
    pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
        [
            "id",
            "ebookId",
            "scrapedAt",
            "thumbnailUrl",
            "price",
            "discount",
            "discountRate",
            "points",
            "pointsRate",
        ]
        .into_iter()
        .map(|o| {
            let builder = ::prisma_client_rust::Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    pub fn create(
        ebook_id: String,
        scraped_at: i64,
        thumbnail_url: String,
        price: f64,
        points: f64,
        points_rate: f64,
        _params: Vec<SetParam>,
    ) -> (String, i64, String, f64, f64, f64, Vec<SetParam>) {
        (
            ebook_id,
            scraped_at,
            thumbnail_url,
            price,
            points,
            points_rate,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_ebook_snapshot { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: ebook_snapshot :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_snapshot :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: ebook_snapshot :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: ebook_snapshot :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_snapshot :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: ebook_snapshot :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , ebook , ebook_id , scraped_at , thumbnail_url , price , discount , discount_rate , points , points_rate } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: ebook_snapshot :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (ebook_id) , stringify ! (scraped_at) , stringify ! (thumbnail_url) , stringify ! (price) , stringify ! (discount) , stringify ! (discount_rate) , stringify ! (points) , stringify ! (points_rate)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: ebook_snapshot :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: ebook_snapshot :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: ebook_snapshot :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "ebook" , "ebookId" , "scrapedAt" , "thumbnailUrl" , "price" , "discount" , "discountRate" , "points" , "pointsRate"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: ebook_snapshot :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { ebook :: Data } ; (@ field_type ; ebook) => { crate :: prisma :: ebook :: Data } ; (@ field_type ; ebook_id) => { String } ; (@ field_type ; scraped_at) => { i64 } ; (@ field_type ; thumbnail_url) => { String } ; (@ field_type ; price) => { f64 } ; (@ field_type ; discount) => { Option < f64 > } ; (@ field_type ; discount_rate) => { Option < f64 > } ; (@ field_type ; points) => { f64 } ; (@ field_type ; points_rate) => { f64 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "EbookSnapshot" , available fields are "id, ebook, ebook_id, scraped_at, thumbnail_url, price, discount, discount_rate, points, points_rate")) } ; (@ field_module ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: id :: Select) } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: ebook :: Select :: $ selection_mode ($ crate :: prisma :: ebook :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: ebook :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; ebook_id) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: ebook_id :: Select) } ; (@ selection_field_to_selection_param ; scraped_at) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: scraped_at :: Select) } ; (@ selection_field_to_selection_param ; thumbnail_url) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: thumbnail_url :: Select) } ; (@ selection_field_to_selection_param ; price) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: price :: Select) } ; (@ selection_field_to_selection_param ; discount) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: discount :: Select) } ; (@ selection_field_to_selection_param ; discount_rate) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: discount_rate :: Select) } ; (@ selection_field_to_selection_param ; points) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: points :: Select) } ; (@ selection_field_to_selection_param ; points_rate) => { Into :: < $ crate :: prisma :: ebook_snapshot :: SelectParam > :: into ($ crate :: prisma :: ebook_snapshot :: points_rate :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: ebook_snapshot :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; ebook) => { "ebook" } ; (@ field_serde_name ; ebook_id) => { "ebookId" } ; (@ field_serde_name ; scraped_at) => { "scrapedAt" } ; (@ field_serde_name ; thumbnail_url) => { "thumbnailUrl" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; discount) => { "discount" } ; (@ field_serde_name ; discount_rate) => { "discountRate" } ; (@ field_serde_name ; points) => { "points" } ; (@ field_serde_name ; points_rate) => { "pointsRate" } ; }
    pub use _select_ebook_snapshot as select;
    pub enum SelectParam {
        Id(id::Select),
        Ebook(ebook::Select),
        EbookId(ebook_id::Select),
        ScrapedAt(scraped_at::Select),
        ThumbnailUrl(thumbnail_url::Select),
        Price(price::Select),
        Discount(discount::Select),
        DiscountRate(discount_rate::Select),
        Points(points::Select),
        PointsRate(points_rate::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Ebook(data) => data.to_selection(),
                Self::EbookId(data) => data.to_selection(),
                Self::ScrapedAt(data) => data.to_selection(),
                Self::ThumbnailUrl(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::Discount(data) => data.to_selection(),
                Self::DiscountRate(data) => data.to_selection(),
                Self::Points(data) => data.to_selection(),
                Self::PointsRate(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_ebook_snapshot { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: ebook_snapshot :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_snapshot :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: ebook_snapshot :: _outputs () ; selections . extend ($ crate :: prisma :: ebook_snapshot :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: ebook_snapshot :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: ebook_snapshot :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: ebook_snapshot :: _outputs () ; selections . extend ($ crate :: prisma :: ebook_snapshot :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { ebook } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub id : String , pub ebook_id : String , pub scraped_at : i64 , pub thumbnail_url : String , pub price : f64 , pub discount : Option < f64 > , pub discount_rate : Option < f64 > , pub points : f64 , pub points_rate : f64 , $ (pub $ field : $ crate :: prisma :: ebook_snapshot :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (ebook_id) , stringify ! (scraped_at) , stringify ! (thumbnail_url) , stringify ! (price) , stringify ! (discount) , stringify ! (discount_rate) , stringify ! (points) , stringify ! (points_rate)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; ebook_id) , & self . ebook_id) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; scraped_at) , & self . scraped_at) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; thumbnail_url) , & self . thumbnail_url) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; price) , & self . price) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount) , & self . discount) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount_rate) , & self . discount_rate) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points) , & self . points) ? ; state . serialize_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points_rate) , & self . points_rate) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , ebook_id , scraped_at , thumbnail_url , price , discount , discount_rate , points , points_rate } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; ebook_id) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; scraped_at) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; thumbnail_url) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; price) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount_rate) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points) , ", " , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points_rate) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; ebook_id) => Ok (Field :: ebook_id) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; scraped_at) => Ok (Field :: scraped_at) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; thumbnail_url) => Ok (Field :: thumbnail_url) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; price) => Ok (Field :: price) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount) => Ok (Field :: discount) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount_rate) => Ok (Field :: discount_rate) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points) => Ok (Field :: points) , $ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points_rate) => Ok (Field :: points_rate) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut ebook_id = None ; let mut scraped_at = None ; let mut thumbnail_url = None ; let mut price = None ; let mut discount = None ; let mut discount_rate = None ; let mut points = None ; let mut points_rate = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: ebook_id => { if ebook_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; ebook_id))) ; } ebook_id = Some (map . next_value () ?) ; } Field :: scraped_at => { if scraped_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; scraped_at))) ; } scraped_at = Some (map . next_value () ?) ; } Field :: thumbnail_url => { if thumbnail_url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; thumbnail_url))) ; } thumbnail_url = Some (map . next_value () ?) ; } Field :: price => { if price . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; price))) ; } price = Some (map . next_value () ?) ; } Field :: discount => { if discount . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount))) ; } discount = Some (map . next_value () ?) ; } Field :: discount_rate => { if discount_rate . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount_rate))) ; } discount_rate = Some (map . next_value () ?) ; } Field :: points => { if points . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points))) ; } points = Some (map . next_value () ?) ; } Field :: points_rate => { if points_rate . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points_rate))) ; } points_rate = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; id))) ? ; let ebook_id = ebook_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; ebook_id))) ? ; let scraped_at = scraped_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; scraped_at))) ? ; let thumbnail_url = thumbnail_url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; thumbnail_url))) ? ; let price = price . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; price))) ? ; let discount = discount . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount))) ? ; let discount_rate = discount_rate . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; discount_rate))) ? ; let points = points . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points))) ? ; let points_rate = points_rate . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: ebook_snapshot :: include ! (@ field_serde_name ; points_rate))) ? ; Ok (Data { id , ebook_id , scraped_at , thumbnail_url , price , discount , discount_rate , points , points_rate , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "ebook" , "ebookId" , "scrapedAt" , "thumbnailUrl" , "price" , "discount" , "discountRate" , "points" , "pointsRate"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: ebook_snapshot :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { ebook :: Data } ; (@ field_type ; ebook) => { crate :: prisma :: ebook :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "EbookSnapshot" , available relations are "ebook")) } ; (@ field_module ; ebook : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: ebook :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: ebook_snapshot :: IncludeParam > :: into ($ crate :: prisma :: ebook_snapshot :: ebook :: Include :: $ selection_mode ($ crate :: prisma :: ebook :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; ebook $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: ebook_snapshot :: IncludeParam > :: into ($ crate :: prisma :: ebook_snapshot :: ebook :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: ebook_snapshot :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; ebook) => { "ebook" } ; (@ field_serde_name ; ebook_id) => { "ebookId" } ; (@ field_serde_name ; scraped_at) => { "scrapedAt" } ; (@ field_serde_name ; thumbnail_url) => { "thumbnailUrl" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; discount) => { "discount" } ; (@ field_serde_name ; discount_rate) => { "discountRate" } ; (@ field_serde_name ; points) => { "points" } ; (@ field_serde_name ; points_rate) => { "pointsRate" } ; }
    pub use _include_ebook_snapshot as include;
    pub enum IncludeParam {
        Id(id::Include),
        Ebook(ebook::Include),
        EbookId(ebook_id::Include),
        ScrapedAt(scraped_at::Include),
        ThumbnailUrl(thumbnail_url::Include),
        Price(price::Include),
        Discount(discount::Include),
        DiscountRate(discount_rate::Include),
        Points(points::Include),
        PointsRate(points_rate::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Ebook(data) => data.to_selection(),
                Self::EbookId(data) => data.to_selection(),
                Self::ScrapedAt(data) => data.to_selection(),
                Self::ThumbnailUrl(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::Discount(data) => data.to_selection(),
                Self::DiscountRate(data) => data.to_selection(),
                Self::Points(data) => data.to_selection(),
                Self::PointsRate(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "ebook")]
        pub ebook: Option<Box<super::ebook::Data>>,
        #[serde(rename = "ebookId")]
        pub ebook_id: String,
        #[serde(rename = "scrapedAt")]
        pub scraped_at: i64,
        #[serde(rename = "thumbnailUrl")]
        pub thumbnail_url: String,
        #[serde(rename = "price")]
        pub price: f64,
        #[serde(rename = "discount")]
        pub discount: Option<f64>,
        #[serde(rename = "discountRate")]
        pub discount_rate: Option<f64>,
        #[serde(rename = "points")]
        pub points: f64,
        #[serde(rename = "pointsRate")]
        pub points_rate: f64,
    }
    impl Data {
        pub fn ebook(
            &self,
        ) -> Result<&super::ebook::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.ebook
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(ebook),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Ebook(super::ebook::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Ebook(args) => {
                    let mut selections = super::ebook::_outputs();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("ebook");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        ConnectEbook(super::ebook::UniqueWhereParam),
        SetEbookId(String),
        SetScrapedAt(i64),
        IncrementScrapedAt(i64),
        DecrementScrapedAt(i64),
        MultiplyScrapedAt(i64),
        DivideScrapedAt(i64),
        SetThumbnailUrl(String),
        SetPrice(f64),
        IncrementPrice(f64),
        DecrementPrice(f64),
        MultiplyPrice(f64),
        DividePrice(f64),
        SetDiscount(Option<f64>),
        IncrementDiscount(f64),
        DecrementDiscount(f64),
        MultiplyDiscount(f64),
        DivideDiscount(f64),
        SetDiscountRate(Option<f64>),
        IncrementDiscountRate(f64),
        DecrementDiscountRate(f64),
        MultiplyDiscountRate(f64),
        DivideDiscountRate(f64),
        SetPoints(f64),
        IncrementPoints(f64),
        DecrementPoints(f64),
        MultiplyPoints(f64),
        DividePoints(f64),
        SetPointsRate(f64),
        IncrementPointsRate(f64),
        DecrementPointsRate(f64),
        MultiplyPointsRate(f64),
        DividePointsRate(f64),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectEbook (where_param) => ("ebook" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: ebook :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()))])) , SetParam :: SetEbookId (value) => ("ebookId" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetScrapedAt (value) => ("scrapedAt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value)) , SetParam :: IncrementScrapedAt (value) => ("scrapedAt" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DecrementScrapedAt (value) => ("scrapedAt" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: MultiplyScrapedAt (value) => ("scrapedAt" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DivideScrapedAt (value) => ("scrapedAt" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: SetThumbnailUrl (value) => ("thumbnailUrl" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) , SetParam :: IncrementPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DividePrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: SetDiscount (value) => ("discount" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: IncrementDiscount (value) => ("discount" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementDiscount (value) => ("discount" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyDiscount (value) => ("discount" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DivideDiscount (value) => ("discount" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: SetDiscountRate (value) => ("discountRate" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: IncrementDiscountRate (value) => ("discountRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementDiscountRate (value) => ("discountRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyDiscountRate (value) => ("discountRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DivideDiscountRate (value) => ("discountRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: SetPoints (value) => ("points" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) , SetParam :: IncrementPoints (value) => ("points" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementPoints (value) => ("points" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyPoints (value) => ("points" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DividePoints (value) => ("points" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: SetPointsRate (value) => ("pointsRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) , SetParam :: IncrementPointsRate (value) => ("pointsRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementPointsRate (value) => ("pointsRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyPointsRate (value) => ("pointsRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DividePointsRate (value) => ("pointsRate" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        EbookId(::prisma_client_rust::Direction),
        ScrapedAt(::prisma_client_rust::Direction),
        ThumbnailUrl(::prisma_client_rust::Direction),
        Price(::prisma_client_rust::Direction),
        Discount(::prisma_client_rust::Direction),
        DiscountRate(::prisma_client_rust::Direction),
        Points(::prisma_client_rust::Direction),
        PointsRate(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EbookId(direction) => (
                    "ebookId".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ScrapedAt(direction) => (
                    "scrapedAt".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ThumbnailUrl(direction) => (
                    "thumbnailUrl".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Price(direction) => (
                    "price".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Discount(direction) => (
                    "discount".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DiscountRate(direction) => (
                    "discountRate".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Points(direction) => (
                    "points".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PointsRate(direction) => (
                    "pointsRate".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdMode(QueryMode),
        IdNot(String),
        EbookIs(Vec<super::ebook::WhereParam>),
        EbookIsNot(Vec<super::ebook::WhereParam>),
        EbookIdEquals(String),
        EbookIdInVec(Vec<String>),
        EbookIdNotInVec(Vec<String>),
        EbookIdLt(String),
        EbookIdLte(String),
        EbookIdGt(String),
        EbookIdGte(String),
        EbookIdContains(String),
        EbookIdStartsWith(String),
        EbookIdEndsWith(String),
        EbookIdMode(QueryMode),
        EbookIdNot(String),
        ScrapedAtEquals(i64),
        ScrapedAtInVec(Vec<i64>),
        ScrapedAtNotInVec(Vec<i64>),
        ScrapedAtLt(i64),
        ScrapedAtLte(i64),
        ScrapedAtGt(i64),
        ScrapedAtGte(i64),
        ScrapedAtNot(i64),
        ThumbnailUrlEquals(String),
        ThumbnailUrlInVec(Vec<String>),
        ThumbnailUrlNotInVec(Vec<String>),
        ThumbnailUrlLt(String),
        ThumbnailUrlLte(String),
        ThumbnailUrlGt(String),
        ThumbnailUrlGte(String),
        ThumbnailUrlContains(String),
        ThumbnailUrlStartsWith(String),
        ThumbnailUrlEndsWith(String),
        ThumbnailUrlMode(QueryMode),
        ThumbnailUrlNot(String),
        PriceEquals(f64),
        PriceInVec(Vec<f64>),
        PriceNotInVec(Vec<f64>),
        PriceLt(f64),
        PriceLte(f64),
        PriceGt(f64),
        PriceGte(f64),
        PriceNot(f64),
        DiscountEquals(Option<f64>),
        DiscountInVec(Vec<f64>),
        DiscountNotInVec(Vec<f64>),
        DiscountLt(f64),
        DiscountLte(f64),
        DiscountGt(f64),
        DiscountGte(f64),
        DiscountNot(f64),
        DiscountRateEquals(Option<f64>),
        DiscountRateInVec(Vec<f64>),
        DiscountRateNotInVec(Vec<f64>),
        DiscountRateLt(f64),
        DiscountRateLte(f64),
        DiscountRateGt(f64),
        DiscountRateGte(f64),
        DiscountRateNot(f64),
        PointsEquals(f64),
        PointsInVec(Vec<f64>),
        PointsNotInVec(Vec<f64>),
        PointsLt(f64),
        PointsLte(f64),
        PointsGt(f64),
        PointsGte(f64),
        PointsNot(f64),
        PointsRateEquals(f64),
        PointsRateInVec(Vec<f64>),
        PointsRateNotInVec(Vec<f64>),
        PointsRateLt(f64),
        PointsRateLte(f64),
        PointsRateGt(f64),
        PointsRateGte(f64),
        PointsRateNot(f64),
    }
    impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
        fn into(self) -> ::prisma_client_rust::SerializedWhere {
            match self { Self :: Not (value) => :: prisma_client_rust :: SerializedWhere :: new ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: Or (value) => :: prisma_client_rust :: SerializedWhere :: new ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => :: prisma_client_rust :: SerializedWhere :: new ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: IdEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: IdNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: IdLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: IdMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: IdNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIs (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("ebook" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: EbookIsNot (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("ebook" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: EbookIdEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: EbookIdNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: EbookIdLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: EbookIdMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: EbookIdNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("ebookId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ScrapedAtEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: ScrapedAtInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))])) , Self :: ScrapedAtNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))])) , Self :: ScrapedAtLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: ScrapedAtLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: ScrapedAtGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: ScrapedAtGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: ScrapedAtNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("scrapedAt" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: ThumbnailUrlEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: ThumbnailUrlNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: ThumbnailUrlLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ThumbnailUrlMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: ThumbnailUrlNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("thumbnailUrl" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PriceEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PriceNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PriceLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: DiscountInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: DiscountNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: DiscountLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("discount" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountRateEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: DiscountRateInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: DiscountRateNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: DiscountRateLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountRateLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountRateGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountRateGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DiscountRateNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("discountRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PointsNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PointsLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("points" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsRateEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsRateInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PointsRateNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PointsRateLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsRateLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsRateGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsRateGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PointsRateNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("pointsRate" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs =
        ::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
    pub type Count<'a> =
        ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
    pub type FindUnique<'a> =
        ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        UniqueWhereParam,
        Data,
    >;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where.into(),
            )
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where,
            )
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where,
            )
        }
        pub fn create(
            self,
            ebook: super::ebook::UniqueWhereParam,
            scraped_at: i64,
            thumbnail_url: String,
            price: f64,
            points: f64,
            points_rate: f64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(ebook::connect(ebook));
            _params.push(scraped_at::set(scraped_at));
            _params.push(thumbnail_url::set(thumbnail_url));
            _params.push(price::set(price));
            _params.push(points::set(points));
            _params.push(points_rate::set(points_rate));
            Create::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _params,
            )
        }
        pub fn create_many(
            self,
            data: Vec<(String, i64, String, f64, f64, f64, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        ebook_id,
                        scraped_at,
                        thumbnail_url,
                        price,
                        points,
                        points_rate,
                        mut _params,
                    )| {
                        _params.push(ebook_id::set(ebook_id));
                        _params.push(scraped_at::set(scraped_at));
                        _params.push(thumbnail_url::set(thumbnail_url));
                        _params.push(price::set(price));
                        _params.push(points::set(points));
                        _params.push(points_rate::set(points_rate));
                        _params
                    },
                )
                .collect();
            CreateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                data,
            )
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where.into(),
                _params,
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where,
                _params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (ebook, scraped_at, thumbnail_url, price, points, points_rate, mut _params): (
                super::ebook::UniqueWhereParam,
                i64,
                String,
                f64,
                f64,
                f64,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(ebook::connect(ebook));
            _params.push(scraped_at::set(scraped_at));
            _params.push(thumbnail_url::set(thumbnail_url));
            _params.push(price::set(price));
            _params.push(points::set(points));
            _params.push(points_rate::set(points_rate));
            Upsert::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where.into(),
                vec![],
            )
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                _where.into(),
            )
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(
                self.client._new_query_context(),
                ::prisma_client_rust::QueryInfo::new("EbookSnapshot", _outputs()),
                vec![],
            )
        }
    }
}
pub mod _prisma {
    pub struct PrismaClient {
        executor: ::prisma_client_rust::Executor,
        query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
    }
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> ::prisma_client_rust::queries::QueryContext {
            ::prisma_client_rust::queries::QueryContext::new(&self.executor, &self.query_schema)
        }
        pub(super) fn _new(
            executor: ::prisma_client_rust::Executor,
            query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    &self.query_schema,
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::raw::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(
                ::prisma_client_rust::queries::QueryContext::new(
                    &self.executor,
                    &self.query_schema,
                ),
                query,
                super::DATABASE_STR,
            )
        }
        pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
            ::prisma_client_rust::batch(queries, &self.executor, &self.query_schema).await
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self }
        }
        pub fn wish_list(&self) -> super::wish_list::Actions {
            super::wish_list::Actions { client: &self }
        }
        pub fn ebook(&self) -> super::ebook::Actions {
            super::ebook::Actions { client: &self }
        }
        pub fn ebook_in_wish_list(&self) -> super::ebook_in_wish_list::Actions {
            super::ebook_in_wish_list::Actions { client: &self }
        }
        pub fn ebook_snapshot(&self) -> super::ebook_snapshot::Actions {
            super::ebook_snapshot::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum EbookInWishListScalarFieldEnum {
        #[serde(rename = "wishListId")]
        WishListId,
        #[serde(rename = "ebookId")]
        EbookId,
    }
    impl ToString for EbookInWishListScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::WishListId => "wishListId".to_string(),
                Self::EbookId => "ebookId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum EbookScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "price")]
        Price,
    }
    impl ToString for EbookScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Url => "url".to_string(),
                Self::Title => "title".to_string(),
                Self::Price => "price".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum EbookSnapshotScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "ebookId")]
        EbookId,
        #[serde(rename = "scrapedAt")]
        ScrapedAt,
        #[serde(rename = "thumbnailUrl")]
        ThumbnailUrl,
        #[serde(rename = "price")]
        Price,
        #[serde(rename = "discount")]
        Discount,
        #[serde(rename = "discountRate")]
        DiscountRate,
        #[serde(rename = "points")]
        Points,
        #[serde(rename = "pointsRate")]
        PointsRate,
    }
    impl ToString for EbookSnapshotScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::EbookId => "ebookId".to_string(),
                Self::ScrapedAt => "scrapedAt".to_string(),
                Self::ThumbnailUrl => "thumbnailUrl".to_string(),
                Self::Price => "price".to_string(),
                Self::Discount => "discount".to_string(),
                Self::DiscountRate => "discountRate".to_string(),
                Self::Points => "points".to_string(),
                Self::PointsRate => "pointsRate".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "displayName")]
        DisplayName,
        #[serde(rename = "email")]
        Email,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::DisplayName => "displayName".to_string(),
                Self::Email => "email".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum WishListScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "scrapedAt")]
        ScrapedAt,
        #[serde(rename = "title")]
        Title,
    }
    impl ToString for WishListScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Url => "url".to_string(),
                Self::ScrapedAt => "scrapedAt".to_string(),
                Self::Title => "title".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
